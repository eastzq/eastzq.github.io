# 算法代码
https://labuladong.gitee.io/algo/ds-class/shu-zu-lia-39fd9/er-fen-cha-b34e4/#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%B3%9B%E5%8C%96

```cpp
#include <iostream>
#include <vector>
int left_bound(std::vector<int>& nums,int target){
    if(nums.size() == 0) return -1;
    int left = 0;
    int right = nums.size();
    while(left < right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            //当找到target时候，收缩右边界
            right = mid;
        } else if (nums[mid] < target)
        {
            left = mid + 1;
        } else if(nums[mid] > target) {
            right = mid;
        }
        
    }
    return left;
}
int right_bound(std::vector<int>& nums,int target){
    if(nums.size() == 0) return -1;
    int left = 0;
    int right = nums.size();
    while(left < right) {
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            left = mid + 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        } else if(nums[mid] > target) {
            right = mid;
        }
    }
    return right;
}
int main(void) {
    std::vector<int> arr = {1,2,3,3,3,4,5,6,7};
    int index = left_bound(arr,3);
    std::cout << "left_bound: " << index << std::endl;
    index = right_bound(arr,3);
    std::cout << "right_bound: " << index << std::endl;
    return 0;
}
```


![](https://static.meowrain.cn/i/2024/01/09/zn1m42-3.webp)

# 什么问题可以运用二分搜索算法技巧？

首先，你要从题目中抽象出一个自变量 x，一个关于 x 的函数 f(x)，以及一个目标值 target。

同时，x, f(x), target 还要满足以下条件：

1、f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。

2、题目是让你计算满足约束条件 f(x) == target 时的 x 的值。

上述规则听起来有点抽象，来举个具体的例子：

给你一个升序排列的有序数组 nums 以及一个目标元素 target，请你计算 target 在数组中的索引位置，如果有多个目标元素，返回最小的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 x, f(x), target 分别是什么呢？

我们可以把数组中元素的索引认为是自变量 x，函数关系 f(x) 就可以这样设定：

```cpp

// 函数 f(x) 是关于自变量 x 的单调递增函数
// 入参 nums 是不会改变的，所以可以忽略，不算自变量
int f(int x, int nums[]) {
    return nums[x];
}
```

其实这个函数 f 就是在访问数组 nums，因为题目给我们的数组 nums 是升序排列的，所以函数 f(x) 就是在 x 上单调递增的函数。

最后，题目让我们求什么来着？是不是让我们计算元素 target 的最左侧索引？

是不是就相当于在问我们「满足 f(x) == target 的 x 的最小值是多少」？

画个图，如下：
![](https://static.meowrain.cn/i/2024/01/09/10dxu1e-3.webp)

如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法。

---

# 例题


![](https://static.meowrain.cn/i/2024/01/09/10fpz1y-3.webp)


```cpp
class Solution {
public:

    int minEatingSpeed(vector<int>& piles, int h) {
        int left = 1;
        int right = 1000000000 + 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if(f(piles,mid) <= h){
                right = mid;
            }else {
                left = mid + 1;
            }
        }
        return left;
    }
    int f(vector<int>& piles,int x) {
        int hours = 0;
        for(int i = 0;i<piles.size();i++){
            hours+=piles[i]/x;
            if(piles[i] % x > 0){
                hours++;
            }
        }
        return hours;
    }
};

```

二分思路
这个题目的思路就是从1-maxvalue里面找最小速度
我们创建一个f函数，f(x)表示以x为速度的时候，用的时间，这样我们和警卫将要回来的时间进行对比，如果小，那么说明速度还能更慢，就继续往左边找



---


![](https://static.meowrain.cn/i/2024/01/10/njvzii-3.webp)
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        vector<int> arr;
        int size = matrix.size()*matrix[0].size();
        for(int i = 0;i<matrix.size();i++){
            for(int j = 0;j<matrix[i].size();j++){
                arr.push_back(matrix[i][j]);
            }
        }
        int l = 0;
        int r = arr.size() - 1;
        while(l <= r){
            int mid = l + (r - l) /2;
            if(arr[mid] == target){
                return true;
            }else if(arr[mid] < target){
                l = mid + 1;
            }else if(arr[mid] > target){
                r = mid - 1;
            }
        }
        return false;
    }
};
```

解法2
> 只要知道二维数组的的行数 m 和列数 n，二维数组的坐标 (i, j) 可以映射成一维的 index = i * n + j；反过来也可以通过一维 index 反解出二维坐标 i = index / n, j = index % n。
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int left = 0;
        int right = m*n - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(get(matrix,mid) == target) {
                return true;
            }else if(get(matrix,mid) > target){
                right = mid - 1;
            }else if(get(matrix,mid) < target) {
                left = mid + 1;
            }
        }
        return false;
    }
    int get(vector<vector<int>>&matrix,int index) {
        int m = matrix.size();
        int n = matrix[0].size();
        int i = index / n;
        int j = index%n;
        return matrix[i][j];
    }
};
```


---

![](https://static.meowrain.cn/i/2024/01/10/nu0aw4-3.webp)

这道题说matrix从上到下递增， 从左到右递增，显然左上角是最小元素，右下角是最大元素。

想高效在matrix中找一个元素，肯定要从某个角开始。

我们从右上角开始，规定至鞥内向左或者向下移动。

如果向左移动，元素变小，向下移动元素变大。这样我们就能根据当前位置的元素和target的相对大小判断往哪边移动，不断接近从而找到target在二维矩阵中的位置。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        // 初始化在右上角
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] < target) {
                // 需要大一点，往下移动
                i++;
            } else {
                // 需要小一点，往左移动
                j--;
            }
        }
        // while 循环中没有找到，则 target 不存在
        return false;
    }
};


```